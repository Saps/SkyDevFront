import { Injectable, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { ActivatedRoute, ActivatedRouteSnapshot, GuardsCheckEnd, Params, Route, Router } from '@angular/router';
import { IBreadcrumb, TBreadcrumbDefinition, TBreadcrumbFunction, TBreadcrumbObject } from '@app/models';
import { BehaviorSubject, filter } from 'rxjs';

function extractObject(config: string | TBreadcrumbFunction | TBreadcrumbObject): TBreadcrumbObject {
  const condition = config && (typeof config === 'string' || typeof config === 'function');
  return (condition && { label: config }) || (config as TBreadcrumbObject) || {};
}

/**
 * If the path segment has route params, read the param value from url for each segment of route this gets called
 * for mentor/:id/view - it gets called with mentor, :id, view 3 times
 */
function resolvePathSegment(path: string, params: Params): string {
  if (path.includes(':')) {
    Object.entries(params).forEach(([key, value]) => (path = path.replace(`:${key}`, `${value}`)));
  }
  return path;
}

/** Set current activated route query params to the last breadcrumb item */
function setQueryParamsForActiveBreadcrumb(breadcrumb: IBreadcrumb, snapshot: ActivatedRouteSnapshot): void {
  if (breadcrumb) {
    const { fragment, queryParams } = snapshot;
    breadcrumb.fragment = fragment ?? undefined;
    breadcrumb.queryParams = queryParams ? { ...queryParams } : undefined;
  }
}

/** @see https://www.npmjs.com/package/xng-breadcrumb */
@Injectable({
  providedIn: 'root',
})
export class BreadcrumbService {
  /** Breadcrumbs observable to be subscribed by BreadcrumbComponent. Emits on every route change OR dynamic update of breadcrumb. */
  public breadcrumbs$ = new BehaviorSubject<TBreadcrumbDefinition[]>([]);
  /**
   * BreadcrumbList for the current route. When breadcrumb info is changed dynamically, check
   * if the currentBreadcrumbs is effected. If effected, update the change and emit a new stream.
   */
  private currentBreadcrumbs: TBreadcrumbDefinition[] = [];

  /**
   * Holds information about dynamically updated breadcrumbs. Breadcrumbs can be set from anywhere
   * (component, service) in the app. On every breadcrumb update check this store and use the info if available.
   */
  private dynamicBreadcrumbStore: TBreadcrumbDefinition[] = [];
  private previousBreadcrumbs: TBreadcrumbDefinition[] = [];
  private readonly router = inject(Router);

  constructor() {
    // Special case where breadcrumb service & component instantiates after a route is navigated.
    // Ex: put breadcrumbs within *ngIf and this.router.events would be empty
    // This check is also required where { initialNavigation: 'enabledBlocking' } is applied to routes
    this.setupBreadcrumbs(inject(ActivatedRoute).snapshot);
    this.router.events
      .pipe(
        filter((event): event is GuardsCheckEnd => event instanceof GuardsCheckEnd),
        takeUntilDestroyed()
      )
      .subscribe((event) => {
        // activatedRoute doesn't carry data when shouldReuseRoute returns false
        // use the event data with GuardsCheckEnd as workaround
        // Check for shouldActivate in case where the authGuard returns false the breadcrumbs shouldn't be changed
        if (event.shouldActivate) this.setupBreadcrumbs(event.state.root);
      });
  }

  /**
   * Update breadcrumb dynamically, key can be a path | alias
   *
   * 1) Using complete route path. route can be passed the same way you define angular routes
   * - path can be passed as 'exact path(routeLink)' or 'path with params(routeRegex)'
   * - update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
   * - change visibility Ex: set('/mentor/:id/edit', { skip: true })
   * ------------------------------------------ OR ------------------------------------------
   * 2) Using route alias (prefixed with '@'). alias should be unique for a route
   * - update label Ex: set('@mentor', 'Enabler')
   * - change visibility Ex: set('@mentorEdit', { skip: true })
   *
   * value can be string | TBreadcrumbFunction | TBreadcrumbObject
   */
  set(key: string, breadcrumb: string | TBreadcrumbObject): void {
    let definition: TBreadcrumbDefinition;
    let store: 'alias' | 'routeLink' | 'routeRegex';
    if (key.startsWith('@')) {
      definition = { ...extractObject(breadcrumb), alias: key.slice(1), isAutoGeneratedLabel: false };
      store = 'alias';
    } else if (key.includes(':')) {
      definition = {
        ...extractObject(breadcrumb),
        isAutoGeneratedLabel: false,
        routeRegex: (key.startsWith('/') ? key : `/${key}`).replace(/\/:[^/]+/g, '/[^/]+'),
      };
      store = 'routeRegex';
    } else {
      definition = { ...extractObject(breadcrumb), isAutoGeneratedLabel: false, routeLink: key.startsWith('/') ? key : `/${key}` };
      store = 'routeLink';
    }

    const i = this.dynamicBreadcrumbStore.findIndex((item: TBreadcrumbDefinition) => definition[store] === item[store]);
    if (i > -1) this.dynamicBreadcrumbStore[i] = { ...this.dynamicBreadcrumbStore[i], ...definition };
    else this.dynamicBreadcrumbStore.push({ ...definition });

    const j = this.currentBreadcrumbs.findIndex((item: TBreadcrumbDefinition) =>
      store === 'routeRegex'
        ? item.routeLink?.match(new RegExp(definition[store] ?? ''))?.[0] === item.routeLink
        : definition[store] === item[store]
    );
    if (j > -1) {
      this.currentBreadcrumbs[j] = { ...this.currentBreadcrumbs[j], ...definition };
      this.breadcrumbs$.next(this.currentBreadcrumbs.filter((item) => !item.skip));
    }
  }

  private setupBreadcrumbs(snapshot: ActivatedRouteSnapshot): void {
    this.previousBreadcrumbs = this.currentBreadcrumbs;
    const rootBreadcrumb = extractObject(this.router.config.find(({ path }) => path === '')?.data?.['breadcrumb']);
    const item = this.getFromStore(rootBreadcrumb.alias, '/');
    const getKeys = Object.keys(rootBreadcrumb).length > 0 || Object.keys(item).length > 0;
    this.currentBreadcrumbs = getKeys ? [{ ...item, ...rootBreadcrumb, routeLink: '/', ...this.getQueryParamsFromPrevious('/') }] : [];
    this.prepareBreadcrumbList(snapshot, '/');
  }

  private prepareBreadcrumbItem(snapshot: ActivatedRouteSnapshot, prefix: string): TBreadcrumbDefinition {
    const { breadcrumb, path = '' } = this.parseRouteData(snapshot.routeConfig);
    const segment = resolvePathSegment(path, snapshot.params);
    const routeLink = `${prefix}${segment}`;
    const storeItem = this.getFromStore(breadcrumb.alias, routeLink);
    const config = storeItem.label || breadcrumb?.label || '';
    const label = typeof config === 'function' ? config(segment) : config;
    return {
      ...storeItem,
      ...breadcrumb,
      label: label || segment,
      routeLink,
      isAutoGeneratedLabel: !label,
      ...this.getQueryParamsFromPrevious(routeLink),
    };
  }

  private prepareBreadcrumbList(snapshot: ActivatedRouteSnapshot, prefix: string): void {
    if (snapshot.routeConfig?.path) {
      const breadcrumbItem = this.prepareBreadcrumbItem(snapshot, prefix);
      this.currentBreadcrumbs.push(breadcrumbItem);
      if (snapshot.firstChild) this.prepareBreadcrumbList(snapshot.firstChild, `${breadcrumbItem.routeLink}/`);
    } else if (snapshot.firstChild) {
      this.prepareBreadcrumbList(snapshot.firstChild, prefix);
    }
    setQueryParamsForActiveBreadcrumb(this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1], snapshot);
    this.breadcrumbs$.next(this.currentBreadcrumbs.filter((item) => !item.skip));
  }

  private getFromStore(alias: string | undefined, routeLink: string): TBreadcrumbDefinition {
    return (
      this.dynamicBreadcrumbStore.find(
        (item) =>
          (alias && alias === item.alias) ||
          (routeLink && routeLink === item.routeLink) ||
          routeLink?.match(new RegExp(item.routeRegex ?? ''))?.[0] === routeLink
      ) ?? {}
    );
  }

  /** queryParams & fragments for previous breadcrumb path are copied over to new list */
  private getQueryParamsFromPrevious(routeLink: string): IBreadcrumb {
    const { fragment, queryParams } = this.previousBreadcrumbs.find(({ routeLink: link }) => routeLink === link) ?? {};
    return { fragment, queryParams };
  }

  /**
   * For a specific route, breadcrumb can be defined either on parent OR it's child(which has empty path)
   * When both are defined, child takes precedence
   *
   * Ex: Below we are setting breadcrumb on both parent and child.
   * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
   * { path: 'home', loadChildren: () => import('./home/home.module').then((m) => m.HomeModule) , data: {breadcrumb: "Defined On Module"}}
   *                                                AND
   * children: [
   *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
   * ]
   */
  private parseRouteData(routeConfig: Route | null) {
    const { data, path } = routeConfig ?? {};
    return { breadcrumb: this.mergeWithBaseChildData(routeConfig, data?.['breadcrumb']), path };
  }

  /**
   * Get empty children of a module or component. Empty child is the one with path: ''
   * When parent and it's children (that has empty route path) define data merge them both with child taking precedence
   */
  private mergeWithBaseChildData(routeConfig: any, config: string | TBreadcrumbFunction | TBreadcrumbObject): TBreadcrumbObject {
    if (!routeConfig) return extractObject(config);
    let baseChild;
    if (routeConfig.loadChildren) {
      // Handle a module with empty child route
      baseChild = routeConfig._loadedRoutes.find((route: any) => route.path === '');
    } else if (routeConfig.children) {
      // Handle a component with empty child route
      baseChild = routeConfig.children.find((route: any) => route.path === '');
    }
    return baseChild?.data?.breadcrumb
      ? this.mergeWithBaseChildData(baseChild, { ...extractObject(config), ...extractObject(baseChild?.data?.breadcrumb) })
      : extractObject(config);
  }
}
